// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

import bitmap show blit
import crypto.crc
import encoding.base64
import host.file
import host.directory
import tls
import tr show Translator

LABEL       ::= "# Label: \""
EXPIRY      ::= "# Expiry: "
SUBJECT     ::= "# Subject: "
FINGERPRINT ::= "# SHA256 Fingerprint: "
ARANY-START ::= "NETLOCK_ARANY"
BEGIN       ::= "-----BEGIN"
END         ::= "-----END"

class Cert:
  mixed-case-name /string
  name/string  // Toit-ified const name.
  sha-fingerprint /string?  // SHA256 Fingerprint
  data /ByteArray  // DER-encoded raw data.
  comment /string?
  is-deprecated/bool
  expiry/string?
  subject/string?

  constructor .mixed-case-name .name .sha-fingerprint .data --.expiry=null --.subject=null --.comment=null --.is-deprecated=false:

  print-on-stdout -> none:
    print "$(name)_BYTES_ ::= #["
    i := 0
    while i < data.size:
      chunk-size := min 18 (data.size - i)
      while chunk-size < data.size - i and (byte-array-encode_ data[i..i + chunk-size + 1]).size <= 78:
        chunk-size++
      section := data[i..i + chunk-size]
      extra := 78 - (byte-array-encode_ section).size
      print
          byte-array-encode_ section --extra=(extra > 4 ? 0 : extra)
      i += chunk-size
    print "]\n"
    print ""
    print "/**"
    print "$(mixed-case-name)."
    print "This certificate can be added to an HTTP client or a TLS socket with"
    print "  the --root_certificates argument."
    print "It can also be installed on the Toit process, to be used by all TLS"
    print "  sockets that do not have explicit roots, using its install method."
    if comment: print comment
    if sha-fingerprint != null:
      print "SHA256 fingerprint: $sha-fingerprint"
    if expiry != null:
      print "Expiry: $expiry"
    if subject != null:
      print "Subject: $subject"
    hash := tls.add-global-root-certificate_ data

    print "*/"
    if is-deprecated:
      print "$name ::= $(name)_"
      print "$(name)_ ::= tls.RootCertificate --fingerprint=0x$(%x hash) $(name)_BYTES_"
    else:
      print "$name ::= tls.RootCertificate --fingerprint=0x$(%x hash) $(name)_BYTES_"
    print ""

byte-array-encode_ slice/ByteArray --extra/int=0 -> string:
  list := List slice.size: slice[it]
  return "    $((list.map: encode-byte_ it --extra=extra: extra -= it).join ","),"

encode-byte_ byte/int --extra/int=0 [report-extra]-> string:
  if ' ' <= byte <= '~' and byte != '\\' and byte != '\'': return "'$(%c byte)'"
  min-size := "$byte".size
  ["0x$(%02x byte)", "0x$(%x byte)", "$byte"].do: | alt |
    if alt.size - min-size <= extra:
      report-extra.call alt.size - min-size
      return alt
  unreachable

main args/List:
  in-cert-data := false
  name := null
  expiry := null
  subject := null
  fingerprint := null
  mixed-case-name := null
  all-certs := {:}  // Mapping from name in the input to Cert object.
  cert-code := []

  print "/// Root certificates, automatically extracted from Mozilla's NSS"
  print ""
  print "// This file was autogenerated from certdata.txt, which carried the"
  print "// following copyright message:"
  print ""
  print "// This Source Code Form is subject to the terms of the Mozilla Public"
  print "// License, v. 2.0. If a copy of the MPL was not distributed with this"
  print "// file, You can obtain one at http://mozilla.org/MPL/2.0/."
  print ""
  print "import encoding.base64"
  print "import net.x509 as net"
  print "import tls"
  print ""
  print "import .get_root"
  print "export get_root_from_exception"
  print ""

  tr := Translator "a-z .-" "A-Z_"
  squeeze := Translator --squeeze "_" "_"

  (file.read-content args[0]).to-string.trim.split "\n": | line |
    line = line.trim
    if line.starts-with FINGERPRINT:
      fingerprint = line[FINGERPRINT.size..]

    if line.starts-with LABEL:
      mixed-case-name = line[LABEL.size..line.size - 1]
      while all-certs.contains mixed-case-name:
        mixed-case-name += " new"
      name = tr.tr mixed-case-name
      if name.starts-with ARANY-START:
        name = "NETLOCK_ARANY"
      name = squeeze.tr name
    if line.starts-with EXPIRY:
      expiry = line[EXPIRY.size..EXPIRY.size + 10]
    if line.starts-with SUBJECT:
      subject = line[SUBJECT.size..]
    if line.starts-with BEGIN:
      in-cert-data = true
    else if line.starts-with END:
      data := base64.decode (cert-code.join "")
      all-certs[mixed-case-name] =
          Cert
              mixed-case-name
              name
              fingerprint
              data
              --expiry=expiry
              --subject=subject
      fingerprint = null
      in-cert-data = false
      expiry = null
      cert-code = []
    else if in-cert-data:
      cert-code.add line

  names := all-certs.keys.sort
  names.do: | mixed-case-name |
    cert/Cert := all-certs[mixed-case-name]
    cert.print-on-stdout

  print ""
  print "/**"
  print "A map from certificate name to \$tls.RootCertificate objects."
  print "The certificates can be used for the --root_certificates"
  print "  argument of TLS sockets."
  print "The certificates can also be installed as globally trusted"
  print "  roots using their install method."
  print "*/"
  print "MAP ::= {"
  names.do: | mixed-case-name |
    cert := all-certs[mixed-case-name]
    if not cert.name.contains "TUNTRUST":
      print "  \"$mixed-case-name\": $(cert.name),"
  print "  \"AAA Certificate Services\": COMODO_AAA_SERVICES_ROOT,"
  print "}"
  print ""
  print "/**"
  print "All the trusted roots in the collection.  If you are running"
  print "  on a non-embedded platform with plenty of memory you can just"
  print "  use them all."
  print "#Note"
  print "The TunTrust cert is only intended for .tn domains, but"
  print "  currently we do not support this restriction in our TLS code,"
  print "  therefore it is currently omitted here, and in \$MAP, but is"
  print "  available on an opt-in basis."
  print "#Examples"
  print "```"
  print "  socket := tls.Socket.client tcp"
  print "      --server_name=host"
  print "      --root_certificates=certificate_roots.ALL"
  print "```"
  print "*/"
  print "ALL ::= ["
  names.do: | mixed-case-name |
    cert := all-certs[mixed-case-name]
    if not cert.name.contains "TUNTRUST":
      if cert.is-deprecated:
        print "  $(cert.name)_,"
      else:
        print "  $cert.name,"
  print "]"
  print ""
  print "// Tries to parse a DER-encoded certificate in the most"
  print "// memory-efficient way.  On older VMs, that that fails."
  print "// In that case, it re-encodes the certificate in PEM"
  print "// format, and retries."
  print "parse_ der_encoded_cert/ByteArray -> net.Certificate:"
  print "  catch:"
  print "    return net.Certificate.parse der_encoded_cert"
  print "  lines := [\"-----BEGIN CERTIFICATE-----\"]"
  print "  List.chunk_up 0 der_encoded_cert.size 144: | from to |"
  print "    encoded := base64.encode der_encoded_cert[from..to]"
  print "    List.chunk_up 0 encoded.size 64: | f t |"
  print "      lines.add encoded[f..t]"
  print "  lines.add \"-----END CERTIFICATE-----\\n\""
  print "  return net.Certificate.parse (lines.join \"\\n\")"
  print ""
  print "/**"
  print "Installs all certificate roots on this process so that they are used"
  print "  for any TLS connections that do not have explicit root certificates."
  print "This adds about 180k to the program size."
  print "*/"
  print "install_all_trusted_roots -> none:"
  names.do: | mixed-case-name |
    cert/Cert := all-certs[mixed-case-name]
    hash := tls.add-global-root-certificate_ cert.data
    print "  $(cert.name).install"
  print ""
  print "/**"
  print "Common certificate roots."
  print "*/"
  print "COMMON_TRUSTED_ROOTS ::= ["
  print "  DIGICERT_GLOBAL_ROOT_G2,"
  print "  DIGICERT_GLOBAL_ROOT_CA,"
  print "  GLOBALSIGN_ROOT_CA,"
  print "  GLOBALSIGN_ROOT_CA_R3,"
  print "  COMODO_AAA_SERVICES_ROOT,"
  print "  COMODO_RSA_CERTIFICATION_AUTHORITY,"
  print "  BALTIMORE_CYBERTRUST_ROOT,"
  print "  USERTRUST_ECC_CERTIFICATION_AUTHORITY,"
  print "  USERTRUST_RSA_CERTIFICATION_AUTHORITY,"
  print "  DIGICERT_HIGH_ASSURANCE_EV_ROOT_CA,"
  print "  ISRG_ROOT_X1,"
  print "  STARFIELD_CLASS_2_CA,"
  print "]"
  print ""
  print "/**"
  print "Installs common certificate roots on this process so that they are used"
  print "  for any TLS connections that do not have explicit root certificates."
  print "This adds about 14k to the program size."
  print "*/"
  print "install_common_trusted_roots -> none:"
  print "  COMMON_TRUSTED_ROOTS.do: it.install"
