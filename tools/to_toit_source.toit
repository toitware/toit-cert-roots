// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

import bitmap show blit
import crypto.crc
import encoding.base64
import host.file
import host.directory
import tls
import tr show Translator

LABEL       ::= "# Label: \""
EXPIRY      ::= "# Expiry: "
SUBJECT     ::= "# Subject: "
FINGERPRINT ::= "# SHA256 Fingerprint: "
ARANY-START ::= "NETLOCK-ARANY"
BEGIN       ::= "-----BEGIN"
END         ::= "-----END"

class Cert:
  mixed-case-name /string
  name/string  // Toit-ified const name.
  sha-fingerprint /string?  // SHA256 Fingerprint
  data /ByteArray  // DER-encoded raw data.
  comment /string?
  is-deprecated/bool
  expiry/string?
  subject/string?

  constructor .mixed-case-name .name .sha-fingerprint .data --.expiry=null --.subject=null --.comment=null --.is-deprecated=false:

  print-on-stdout -> none:
    print """
      /**
      $(mixed-case-name).
      This certificate can be added to an HTTP client or a TLS socket with
        the --root_certificates argument.
      It can also be installed on the Toit process, to be used by all TLS
        sockets that do not have explicit roots, using its install method."""
    if comment: print comment
    if sha-fingerprint != null:
      print "SHA256 fingerprint: $sha-fingerprint"
    if expiry != null:
      print "Expiry: $expiry"
    if subject != null:
      print "Subject: $subject"
    hash := tls.add-global-root-certificate_ data

    print "*/"
    if is-deprecated:
      print """
          $name ::= $(name)_
          $(name)_ ::= tls.RootCertificate --fingerprint=0x$(%x hash) $(name)-BYTES_"""
    else:
      print "$name ::= tls.RootCertificate --fingerprint=0x$(%x hash) $(name)-BYTES_"
    print ""
    print "$(name)-BYTES_ ::= #["
    i := 0
    while i < data.size:
      chunk-size := min 18 (data.size - i)
      while chunk-size < data.size - i and (byte-array-encode_ data[i..i + chunk-size + 1]).size <= 78:
        chunk-size++
      section := data[i..i + chunk-size]
      extra := 78 - (byte-array-encode_ section).size
      print
          byte-array-encode_ section --extra=(extra > 4 ? 0 : extra)
      i += chunk-size
    print "]\n"
    print ""

byte-array-encode_ slice/ByteArray --extra/int=0 -> string:
  list := List slice.size: slice[it]
  return "    $((list.map: encode-byte_ it --extra=extra: extra -= it).join ","),"

encode-byte_ byte/int --extra/int=0 [report-extra]-> string:
  if ' ' <= byte <= '~' and byte != '\\' and byte != '\'': return "'$(%c byte)'"
  min-size := "$byte".size
  ["0x$(%02x byte)", "0x$(%x byte)", "$byte"].do: | alt |
    if alt.size - min-size <= extra:
      report-extra.call alt.size - min-size
      return alt
  unreachable

to-json-map-string map/Map -> string:
  result := "{\n"
  map.keys.sort.map: | key |
    result += "  \"$key\": $(map[key]),\n"
  return result + "}"

to-json-list-string list/List -> string:
  return "[\n  $(list.join ",\n  ")\n]"

main args/List:
  in-cert-data := false
  name := null
  expiry := null
  subject := null
  fingerprint := null
  mixed-case-name := null
  all-certs := {:}  // Mapping from name in the input to Cert object.
  cert-code := []

  print """
      /// Root certificates, automatically extracted from Mozilla's NSS

      // This file was autogenerated from certdata.txt, which carried the
      // following copyright message:

      // This Source Code Form is subject to the terms of the Mozilla Public
      // License, v. 2.0. If a copy of the MPL was not distributed with this
      // file, You can obtain one at http://mozilla.org/MPL/2.0/.

      import encoding.base64
      import net.x509 as net
      import tls

      import .get-root
      export get-root-from-exception
      """

  tr := Translator "a-z ._" "A-Z-"
  squeeze := Translator --squeeze "-" "-"

  (file.read-content args[0]).to-string.trim.split "\n": | line |
    line = line.trim
    if line.starts-with FINGERPRINT:
      fingerprint = line[FINGERPRINT.size..]

    if line.starts-with LABEL:
      mixed-case-name = line[LABEL.size..line.size - 1]
      while all-certs.contains mixed-case-name:
        mixed-case-name += " new"
      name = tr.tr mixed-case-name
      if name.starts-with ARANY-START:
        name = "NETLOCK-ARANY"
      name = squeeze.tr name
    if line.starts-with EXPIRY:
      expiry = line[EXPIRY.size..EXPIRY.size + 10]
    if line.starts-with SUBJECT:
      subject = line[SUBJECT.size..]
    if line.starts-with BEGIN:
      in-cert-data = true
    else if line.starts-with END:
      data := base64.decode (cert-code.join "")
      all-certs[mixed-case-name] =
          Cert
              mixed-case-name
              name
              fingerprint
              data
              --expiry=expiry
              --subject=subject
      fingerprint = null
      in-cert-data = false
      expiry = null
      cert-code = []
    else if in-cert-data:
      cert-code.add line

  names := all-certs.keys.sort
  names.do: | mixed-case-name |
    cert/Cert := all-certs[mixed-case-name]
    cert.print-on-stdout

  out-map := {:}
  names.do: | mixed-case-name |
    cert/Cert := all-certs[mixed-case-name]
    if not cert.name.contains "TUNTRUST":
      out-map[mixed-case-name] = cert.name
  out-map["AAA Certificate Services"] = "COMODO-AAA-SERVICES-ROOT"

  out-list := []
  names.do: | mixed-case-name |
    cert/Cert := all-certs[mixed-case-name]
    if not cert.name.contains "TUNTRUST":
      if cert.is-deprecated:
        out-list.add "$(cert.name)_"
      else:
        out-list.add cert.name

  print ""
  print """
      /**
      A map from certificate name to \$tls.RootCertificate objects.
      The certificates can be installed as globally trusted
        roots using their \$tls.RootCertificate.install method.
      The certificates can also be used for the --root-certificates
        argument of TLS sockets.
      */
      MAP ::= $(to-json-map-string out-map)

      /**
      All the trusted roots in the collection.  If you are running
        on a non-embedded platform with plenty of memory you can just
        use them all.

      # Note
      The TunTrust cert is only intended for .tn domains, but
        currently we do not support this restriction in our TLS code,
        therefore it is currently omitted here, and in \$MAP, but is
        available on an opt-in basis.

      # Examples
      Explicitly pass the root certificates to a TLS socket.
      (Typically, you would use \$install-all-trusted-roots instead.)
      ```
        socket := tls.Socket.client tcp
            --server-name=host
            --root-certificates=certificate-roots.ALL
      ```
      */
      ALL ::= $(to-json-list-string out-list)

      /**
      Installs all certificate roots on this process so that they are used
        for any TLS connections that do not have explicit root certificates.
      This adds about 180k to the program size.
      */
      install-all-trusted-roots -> none:
        $((names.map: | mixed-case-name |
            cert/Cert := all-certs[mixed-case-name]
            hash := tls.add-global-root-certificate_ cert.data
            "$(cert.name).install").join "\n  ")

      /**
      Common certificate roots.
      */
      COMMON-TRUSTED-ROOTS ::= [
        DIGICERT-GLOBAL-ROOT-G2,
        DIGICERT-GLOBAL-ROOT-CA,
        GLOBALSIGN-ROOT-CA,
        GLOBALSIGN-ROOT-CA-R3,
        COMODO-RSA-CERTIFICATION-AUTHORITY,
        BALTIMORE-CYBERTRUST-ROOT,
        USERTRUST-ECC-CERTIFICATION-AUTHORITY,
        USERTRUST-RSA-CERTIFICATION-AUTHORITY,
        DIGICERT-HIGH-ASSURANCE-EV-ROOT-CA,
        ISRG-ROOT-X1,
        STARFIELD-CLASS-2-CA,
        COMODO-AAA-SERVICES-ROOT,
      ]

      /**
      Installs common certificate roots on this process so that they are used
        for any TLS connections that do not have explicit root certificates.
      This adds about 14k to the program size.
      */
      install-common-trusted-roots -> none:
        COMMON-TRUSTED-ROOTS.do: it.install"""
